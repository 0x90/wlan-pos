#!/bin/bash
#usage: basename [OPTION] 
VER=0.1

# Default init
aio=0
start_spid=1
stop_spid=1
runtimes=60
fakegps=1
nstop=0

Version ()
{
    cat <<VER

GNU `basename $0` version $VER, by Yan Xiaotian
Built on i686-ubuntu-linux-gnu
Copyright (C) `date +%Y` Free Software Foundation, Inc.
This is free software; see the source for copying conditions.
There is NO warranty; not even for MERCHANTABILITY or FITNESS FOR A
PARTICULAR PURPOSE.

Report bugs to <xiaotian.yan@gmail.com>.

VER
    exit 0
}
Usage()
{
	cat <<HELP

run -- WLAN location fingerprinting running script.

USAGE: run [OPTION] ...
OPTION: 
-a     all in one processing(default: no, only offline processing)
-f     start spid number(included)(default: 1)
-g     offline fake GPS receiving(default: yes)
-h     show this help
-n     non-stop automated offline calibration
-r     number of samples for each spid(default: 30)
-t     stop spid number(included)(default: 1)
-v     show version information

EXAMPLE:
Offline radio map generation for spid from 1 to 100(60 scans each, 
with fake GPS enabled), followed by online locationing.
#run -a -g -f 1 -t 100 -r 60
Offline WLAN data calibration, filtering, clustering and sql tabling continuously.
#run -n <start_spid>

HELP
	exit 0
}

[ $# -eq 0 ] && Usage
#x=1   # Avoids an error if we get no options at all.
while getopts "af:ghn:or:t:v" opt; do
    OPTERR=0 #error msg shutup
    case $opt in
        a ) aio=1 ;;
        f ) start_spid=$OPTARG ;;
        g ) fakegps=1 ;;
        h ) Usage ;;
        n ) 
            nstop=1 
			cnt=$OPTARG
            offopts="-v"
            #offopts="-v -f"
        ;;
        r ) runtimes=$OPTARG ;;
        t ) stop_spid=$OPTARG ;;
        v ) Version ;;
        * )
			echo -e "\nSorry, BAD or IMCOMPLETE options: '$@' !"
            Usage
        ;;
    esac
  x=$OPTIND
done
#shift $(($x-1))
#echo "Left overs: $@"
#exit 0

date=`date +%Y-%m%d`

if [ $nstop -eq 1 ]; then
	goon=0
    while true;
    do
        echo "Offline procedure begins at sampling point [$cnt]......."
        echo -n "Continue[Y/n]?"
        #FIXME: Parameters interactive confirm.
        read -s opt
        echo " $opt"
        if [ "$opt" != "n" -a "$opt" != "N" ]; then
            goon=1
            sudo ./offline.py $offopts -s $runtimes -i $cnt
			[ $? -eq 0 ] || exit 99

            spidfmt=`printf '%06d' $cnt`
            rawfilename=$date-$spidfmt.raw
            echo -e "\nGenerating rmp file...\n"
            ./offline.py -v -t dat/$rawfilename
            echo "-----------------------------------------------------------------"
            cnt=`expr $cnt + 1`
        else
            [ $goon -eq 1 ] && break || exit 0
        fi
    done

    echo -e "\nRenaming tbl files to be ready for clustering...\n"
	[ -f tbl/cidaps.tbl ] && mv -f tbl/cidaps.tbl tbl/cidaps-$date.tbl.bak
	[ -f tbl/cfprints.tbl ] && mv -f tbl/cfprints.tbl tbl/cfprints-$date.tbl.bak

    echo -e "\nClustering...\n"
    rmpfilename=$date.rmp
    #./offline.py -c dat/$rmpfilename

    echo -e "\nUpload SQL tables...\n"
    #./offline.py -u 1

    exit 0
fi

[ $fakegps = 1 ] && offopts="-v -f" || offopts="-v "
onopts="-v "
#onopts="-v -a 2"

for spid in $(seq $start_spid $stop_spid)
do
    echo "Sampling Point [$spid]"
	./offline.py $offopts -s $runtimes -i $spid
	spidfmt=`printf '%06d' $spid`
	rawfilename=$date-$spidfmt.raw
	./offline.py -v -t dat/$rawfilename
	echo "-----------------------------------------------------------------"
done
if [ $aio -eq 1 ]; then
    rmpfilename=$date.rmp
    ./online.py $onopts -i dat/$rmpfilename
fi


exit 0
RUNTIME=10
RUNFILE=offline.py
LOGPATH=log

if [ $# -lt 1 ]; then
    date=`date +%Y%m%d-%H%M%S`
    echo -e "\nTime: $date\n"
    LOGFILE=$LOGPATH/log-$date
    declare -a LOGFILES=( $LOGFILE )
    [ -d ${LOGPATH} ] || mkdir ${LOGPATH}
    [ -f ${LOGFILE} ] && mv -f ${LOGFILE} ${LOGFILE}.bak
    for x in $(seq ${RUNTIME})
    do
        echo "Survey $x:"
        sudo python ${RUNFILE} |tee -a ${LOGFILE}
        echo "-------------------------------------------------------------"
    done
else
	declare -a LOGFILES=( "$@" )
fi 


for LOGFILE in ${LOGFILES[@]}
do
    echo -ne "\nChecking ${LOGFILE##*/} ... "
    #Integrity checking.
    stat_gga=`grep -e 'GGA' ${LOGFILE} |wc -l`
    stat_gll=`grep -e 'GLL' ${LOGFILE} |wc -l`
    #stat_rmc=`grep -e 'RMC' ${LOGFILE} |wc -l`
    stat_all=`expr ${stat_gga} + ${stat_gll}`

    stat_loc_all=`echo "($stat_all) * 2" |bc`
    stat_loc_mline=`grep -e '^ *116' -e '^ *39' ${LOGFILE} |wc -l`
    stat_loc_sline_noap=`sed -n "/^\['[0-9]*\-[0-9]*', 116\.[0-9]*, 39\.[0-9]*, \[\]]/p" ${LOGFILE} |wc -l`
    stat_loc_all=`echo "(${stat_loc_mline}) + (${stat_loc_sline_noap}) * 2" |bc`
    echo "OK"

    printf "Total scan: %16d\n" ${stat_all}
    echo "-------------------------------"
    printf "GGA: %23d\nGLL: %23d\nRMC: %23d\n" ${stat_gga} ${stat_gll} ${stat_rmc}
    printf "Lat/Lon OK: %13d/%02d\n" ${stat_loc_all} ${stat_loc_all}
    printf "WLAN scan OK: %11d/%02d\n" `expr ${stat_all} - ${stat_loc_sline_noap}` ${stat_all}
    echo -e "-------------------------------\n"
done
